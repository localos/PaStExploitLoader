#!/usr/bin/env perl -w

#####################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################


#####################################################
#
# Simple script for downloading exploits 
# from packetstorm.com
#
# Author: solacol
# Version: 0.2
# Tested with Perl version 5.26.1
#
#####################################################
#
#
# TODO:
#   - Set specific start month/year
#	- Store years and months in array or use some posix shit
#	- Check md5 after storing
#	- Check if file already exists (use checksum to compare)
#   - Skip yearly, use title for this
#   - FIXME problems with Perl version >5.27 vs. xlocale.h vs Net::SSLeay
#
# CHANGELOG:
#	- Basic functionality
#
###


use strict;
use warnings;
use POSIX qw{ strftime };
use LWP::Simple qw{ getstore};
use LWP::UserAgent;
use HTML::TokeParser::Simple;
use Digest::MD5;
use utf8;


# Url, dir, file related stuff 
my $baseUrl = 'https://packetstormsecurity.com';
my $searchUrl = $baseUrl.'/search/?q=Packet+Storm+New+Exploits+For';
my $dlBaseUrl = 'https://dl.packetstormsecurity.net';
my $searchPageUrl = '/search/files/page1/?q=Packet%20Storm%20New%20Exploits%20For';
my $storDir = '/tmp';

# Some additional config stuff
my $startYear = '2000';
my $startMonth = 'June';
my $skipYearly = 'yes';
my $pageCount = 0;
my $loopCount = 1;
my $sleepRange = 5;

# Some pre checks
die("FAILURE: ".__FILE__.':'.__LINE__." $!\n") if(fct_preChecks($storDir));

# Preparing for ssl
my $usag = LWP::UserAgent->new(ssl_opts => {verify_hostname => 0});

# Get rid of http status code 413
#"Sorry, you look like part of a botnet. Please email 'staff' if this is incorrect."
$usag->agent('Wget/1.19 (linux-gnu)');

# Get website
my $website = fct_getFileContentOnly($searchUrl,$usag);

# Check for "errors" and get page count
if(defined($website) && $website !~ m/^1$/ && $website =~ m/\<strong\>Page [0-9]{1,} of ([0-9]{1,})\<\/strong\>/){
    # Pagecount
    $pageCount = $1;
    
    if(defined($pageCount) && $pageCount > 0){
    
        # Loop until page count is reached or an error occured
        do{
            # Construtor
            my $parser = HTML::TokeParser::Simple->new(string =>$website);

            # TODO error handling
            # TODO extract title
            # TODO extract md5sum
            
            # Loop through html and extract hrefs
            while(my $tag = $parser->get_tag('a')){
	            my $href = $tag->get_attr('href');

                # Check for needed href
                if(defined($href) && $href =~ m/\/([0-9]{4,4}\-exploits\.tgz)$/ && defined($1)){
                    my $file = $1;
                    
                    # Set up download url and storing stuff
                    my $getUrl = $dlBaseUrl.$href;
                    $file = $storDir.'/'.$file;

                    # Download
                    if(fct_getFileOnline($getUrl,$file)){
                        warn("FAILURE: ".__FILE__.':'.__LINE__." $!\n");
                        
                        
                        # TODO check md5 and if mismatch skip
                        
                        
                    }
                    else{
                        next;
                    }
                }
                else{
                    next;
                }
            }
            
            # Sleep random
            sleep(rand($sleepRange));
            
            # Increase loop counter and adjust url
            $loopCount++;
            $searchPageUrl =~ s/\/page\d\//\/page$loopCount\//;
            $searchUrl = $baseUrl.$searchPageUrl;
                
            # Get next page
            $website = fct_getFileContentOnly($searchUrl,$usag);
        }while(defined($website) && $website !~ m/^1$/ && $loopCount <= $pageCount);
    }
    else{
        die("FAILURE: Something ssems to be wrong with the page count?! ".__FILE__.':'.__LINE__." $!\n");
    }
}
else{
    die("FAILURE: Website seems to be malformed?! ".__FILE__.':'.__LINE__." $!\n");
}


### Function for software checks
sub fct_preChecks{
    my $dir =$_ [0];
    my $pathWget = '';
    
    $pathWget=`which\ wget\ 2\>\ \/dev\/null`;
    chomp($pathWget);
    
    if($pathWget !~ m/wget/i){
        warn("FAILURE: Wget installed? Check PATH ENV!".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    elsif(! eval "use Net::SSLeay; 1"){ # FIXME not really needed, perl will complain if used module is not in path
        warn("FAILURE: Perl modul Net::SSLeay installed? ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    elsif(! eval "use LWP::Protocol::https; 1"){ # FIXME not really needed, perl will complain if used module is not in path
        warn("FAILURE: Perl modul LWP::Protocol::https installed? ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    elsif(! eval "use HTML::TokeParser::Simple; 1"){ # FIXME not really needed, perl will complain if used module is not in path
        warn("FAILURE: Perl modul HTML::TokeParser::Simple installed? ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    elsif(! eval "use LWP::UserAgent; 1"){ # FIXME not really needed, perl will complain if used module is not in path
        warn("FAILURE: Perl modul LWP::UserAgent installed? ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    elsif(! eval "use Digest::MD5; 1"){ # FIXME not really needed, perl will complain if used module is not in path
        warn("FAILURE: Perl modul Digest::MD5 installed? ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    elsif(! eval "use POSIX; 1"){ # FIXME not really needed, perl will complain if used module is not in path
        warn("FAILURE: Perl modul POSIX installed? ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    elsif(! eval "use LWP::Simple; 1"){ # FIXME not really needed, perl will complain if used module is not in path
        warn("FAILURE: Perl modul LWP::Simple installed? ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
    
    # Check if directory exists
    unless(defined($dir) && -d "$dir"){
        warn("FAILURE: $dir no found ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }

    return(0);
}

### Function for checking md5 hashes
sub fct_checkMd5{
    my $file = $_[0];
    my $beMd5 = $_[1];

    if(defined($file) && defined($beMd5)){
        # Open file and create handle
        open(my $fh, '<', $file) or return(1), warn("FAILURE: Could not open $file! ".__FILE__.':'.__LINE__." $!\n");
        binmode($fh);
        
        # Calculate md5 hash
        my $isMd5 = Digest::MD5->new->addfile($fh)->hexdigest;
        
        if($isMd5 eq $beMd5){
            return(0);
        }
        else{
            warn("FAILURE: Md5 mismatch?!?!?! ".__FILE__.':'.__LINE__." $!\n");
            return(1);
        }
    }
    else{
        warn("FAILURE: File or md5 hash not defined! ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
}

### Function for downloading a file
sub fct_getFileOnline{
    my $url = $_[0];
    my $file = $_[1];

    print("Download file $url ...\n");

    # Simple fallback to wget if getstore fails
    unless(getstore($url, $file) == 200){
        # Fallback if getstore() fails
        warn("WARNING: Problems!? Trying wget ...".__FILE__.':'.__LINE__." \n");
        return(1), warn("FAILURE: Could not get file $file! ".__FILE__.':'.__LINE__." $!\n") if(system("wget\ \-q\ $url\ \-O\ $file"));
    }

    return(0);
}

### Function to get online content without saving the file
sub fct_getFileContentOnly{
    my $url = $_[0];
    my $obj = $_[1];
    my $content = '';
    my @a_content = ();
    my @a_rray = ();
    
    # Get content of url and save it to var
    unless(defined($content = $obj->get($url))){
        # Fallback if get() fails
        warn("WARNING: Problems!? Trying wget ...".__FILE__.':'.__LINE__." \n");
        @a_content = `wget\ \-q\ \-O\ \-\ $url`;

        if(scalar(@a_content) > 1){
            return(join("\n", @a_content));
        }
        else{
            warn("FAILURE: Could not get content of $url! $content->status_line ".__FILE__.':'.__LINE__." $!\n");
            return(1);
        }
    }

    # Retrun content
    return($content->decoded_content);
}


### Function to check if a file is existent
sub fct_checkFile{
    my $file = $_[0];

    # Check if file is given
    return(1), warn("FAILURE: No file given! ".__FILE__.':'.__LINE__." \n")  unless(defined($file));

    # Check if file exists
    if(-f "$file" ){
        return(0); # found, existent
    }
    elsif(! -f "$file"){
        return(2); # not found, not existent
    }
    else{
        warn("FAILURE: ".__FILE__.':'.__LINE__." $!\n");
        return(1);
    }
}
